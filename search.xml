<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Flink水位线不触发的几点总结]]></title>
      <url>/2018/04/25/Flink%E6%B0%B4%E4%BD%8D%E7%BA%BF%E4%B8%8D%E8%A7%A6%E5%8F%91%E7%9A%84%E5%87%A0%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>窗口计算时遇到好几次水位线不触发的情况，简单总结下。</p>
<p>首先，介绍下Flink的事件时间(EventTime)和水位线(Watermarks)的概念。</p>
<h2 id="一、处理时间"><a href="#一、处理时间" class="headerlink" title="一、处理时间"></a>一、处理时间</h2><p>如果要构造一个实时的流式应用，或早或晚都会接触到EventTime这个概念。现实场景中也会遇到消息乱序到达，这里会介绍到为什么需要事件时间和如何去处理乱序到达的数据。<br>ProcessingTime是Flink系统处理这条消息的时间，EventTime可以理解成是这条消息真实发生的时间。<br>举个例子，创建一个SlidingWindow，窗口大小为10秒，步长为5秒。关于窗口的更多概念，可以参考<a href="http://flink.iteblog.com/dev/windows.html" target="_blank" rel="noopener">Flink官方文档——Windows</a>。</p>
<h3 id="案例1：消息都按时到达"><a href="#案例1：消息都按时到达" class="headerlink" title="案例1：消息都按时到达"></a>案例1：消息都按时到达</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> text = senv.socketTextStream(<span class="string">"localhost"</span>, <span class="number">9999</span>)</span><br><span class="line"><span class="keyword">val</span> counts = text.map &#123;(m: <span class="type">String</span>) =&gt; (m.split(<span class="string">","</span>)(<span class="number">0</span>), <span class="number">1</span>) &#125;</span><br><span class="line">    .keyBy(<span class="number">0</span>)</span><br><span class="line">    .timeWindow(<span class="type">Time</span>.seconds(<span class="number">10</span>), <span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">    .sum(<span class="number">1</span>)</span><br><span class="line">counts.print</span><br><span class="line">senv.execute(<span class="string">"ProcessingTime processing example"</span>)</span><br></pre></td></tr></table></figure>
<p>如果source中有三条消息，对应的事件时间分别为13秒、13秒和16秒：<br><img src="/uploads/watermarks/pr_ino_source.png" alt="pr_ino_source"><br>它们会落到正确的窗口上，如下图所示。13秒产生的两条消息会落到窗口1[5s-15s]和窗口2[10s-20s]上，16秒产生的消息会落到窗口2[10s-20s]和窗口3[15s-25s]上。最后窗口fire掉时，三个窗口的count值分别为：(a,2), (a,3) and (a,1) ，和预期一致。<br><img src="/uploads/watermarks/pr_ino_windows.png" alt="pr_ino_windows"></p>
<h3 id="案例2：消息delay"><a href="#案例2：消息delay" class="headerlink" title="案例2：消息delay"></a>案例2：消息delay</h3><p>其中一条13秒产生的消息晚到了6s，那按上面的代码逻辑，这些消息会落到下面的窗口中：<br><img src="/uploads/watermarks/pr_ooo_windows.png" alt="pr_ooo_windows"><br>延迟的消息会落到窗口2[10s-20s]和窗口3[15s-25s]上。这看起来对窗口2没有影响，因为结果都是3，但窗口3的结果却不一致了。</p>
<h2 id="二、事件时间"><a href="#二、事件时间" class="headerlink" title="二、事件时间"></a>二、事件时间</h2><p>因此此处我们采用事件时间，这里水位线的事件时间为当前系统的时间，当然你可以改成数据中的某个时间。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimestampExtractor</span> <span class="keyword">extends</span> <span class="title">AssignerWithPeriodicWatermarks</span>[<span class="type">String</span>] <span class="keyword">with</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(e: <span class="type">String</span>, prevElementTimestamp: <span class="type">Long</span>) = &#123;</span><br><span class="line">    e.split(<span class="string">","</span>)(<span class="number">1</span>).toLong </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getCurrentWatermark</span></span>(): <span class="type">Watermark</span> = &#123; </span><br><span class="line">      <span class="keyword">new</span> <span class="type">Watermark</span>(<span class="type">System</span>.currentTimeMillis)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">senv.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"><span class="keyword">val</span> text = senv.socketTextStream(<span class="string">"localhost"</span>, <span class="number">9999</span>)</span><br><span class="line">                .assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">TimestampExtractor</span>) </span><br><span class="line"><span class="keyword">val</span> counts = text.map &#123;(m: <span class="type">String</span>) =&gt; (m.split(<span class="string">","</span>)(<span class="number">0</span>), <span class="number">1</span>) &#125;</span><br><span class="line">      .keyBy(<span class="number">0</span>)</span><br><span class="line">      .timeWindow(<span class="type">Time</span>.seconds(<span class="number">10</span>), <span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">      .sum(<span class="number">1</span>)</span><br><span class="line">counts.print</span><br><span class="line">senv.execute(<span class="string">"EventTime processing example"</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下图所示：<br><img src="/uploads/watermarks/ev_ooo_windows.png" alt="ev_ooo_windows"><br>结果看起来好很多，窗口2和3都正确了，但窗口1却丢了一条数据。<br>Flink没有将delay的数据分配给窗口3是因为现在是检查消息的事件时间，因此不会放入窗口三中。而没有分配给窗口1的原因是delayed的消息到达系统的时间是19秒，窗口1已经fire掉了。此处就需要watermarks了。</p>
<h2 id="三、水位线（水印）"><a href="#三、水位线（水印）" class="headerlink" title="三、水位线（水印）"></a>三、水位线（水印）</h2><p>我认为水位线是很重要和有趣的一个概念，我这里会大概描述下，如果想了解更多可以看<a href="https://www.youtube.com/watch?v=3UfZN59Nsk8" target="_blank" rel="noopener">Google一场精彩的talk</a>，也可以看这个<a href="https://data-artisans.com/blog/how-apache-flink-enables-new-streaming-applications-part-1" target="_blank" rel="noopener">dataArtisans的blog</a>。水位线简单理解就是一个timestamp，当Flink收到这个水印时，Flink理解会收到来自这个时间点之后的消息，也可以理解成告诉Flink运行到哪个事件时间了。<br>在这个案例中，其实就是告诉Flink一条消息可以迟到多久。<br>我现在设置水位线为现在的事件提前5秒，相当于告诉Flink我的消息可以迟到五秒。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getCurrentWatermark</span></span>(): <span class="type">Watermark</span> = &#123; </span><br><span class="line">      <span class="keyword">new</span> <span class="type">Watermark</span>(<span class="type">System</span>.currentTimeMillis - <span class="number">5000</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>结果变成下图所示:<br><img src="/uploads/watermarks/ev_ooo_windows_wat.png" alt="ev_ooo_windows_wat"></p>
<h2 id="四、允许延迟-Lateness"><a href="#四、允许延迟-Lateness" class="headerlink" title="四、允许延迟(Lateness)"></a>四、允许延迟(Lateness)</h2><p>如果采用“watermark - delay”，如果水位线不超过window_length + delay是不会被fire掉的，所以此刻可以采用allowedLateness方法。在window_end_time + allowed lateness之前，Flink都不会丢弃这条数据。<br>当消息到达时，Flink会提取它的时间，然后判断它是否在有效的延迟时间内，然后去判断是否fire掉窗口。<br>但是通过这种途径，一个窗口有可能被fire掉多次，如果需要exactly once processing的话，需要保证sink是幂等的。</p>
<h2 id="五、水位线怎么不触发？"><a href="#五、水位线怎么不触发？" class="headerlink" title="五、水位线怎么不触发？"></a>五、水位线怎么不触发？</h2><p>数据一直有序得进来，为什么没有窗口被fire掉？没有结果产出？</p>
<h3 id="case1：提取时间失败"><a href="#case1：提取时间失败" class="headerlink" title="case1：提取时间失败"></a>case1：提取时间失败</h3><p>笔者和上游约定好了数据格式，extractTimestamp中提取的是某个字段为事件时间。研究数据发现约定好的字段突然不发了。</p>
<h3 id="case2：提取时间有了，但是照样失败"><a href="#case2：提取时间有了，但是照样失败" class="headerlink" title="case2：提取时间有了，但是照样失败"></a>case2：提取时间有了，但是照样失败</h3><p>上游按约定发了该字段后，系统在测试环境运行了一段时间，又没有结果产出了。<br>调试发现提取时间正常，checkAndGetNextWatermark也正常，但是为什么窗口没被fire掉呢。<br>因为时间的format变了，由到毫秒的timestamp变成了yyyymmddHHmmss，需要转成timestamp。</p>
<h3 id="case3：一切正常，窗口不fire"><a href="#case3：一切正常，窗口不fire" class="headerlink" title="case3：一切正常，窗口不fire"></a>case3：一切正常，窗口不fire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EventTimeTrigger.java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TriggerResult <span class="title">onElement</span><span class="params">(Object element, <span class="keyword">long</span> timestamp, TimeWindow window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (window.maxTimestamp() &lt;= ctx.getCurrentWatermark()) &#123;</span><br><span class="line">		<span class="comment">// if the watermark is already past the window fire immediately</span></span><br><span class="line">		<span class="keyword">return</span> TriggerResult.FIRE;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ctx.registerEventTimeTimer(window.maxTimestamp());</span><br><span class="line">		<span class="keyword">return</span> TriggerResult.CONTINUE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了下EventTimeTrigger的源码，只有当当前的水位线越过窗口，即时间大于窗口的endTime才会触发Fire的操作。我们的处理流程没有触发，那就说明我们的水位线没有更新到合适的值。调试后发现当前的水位线一直停留在初始的最小的long值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BoundedOutOfOrdernessTimestampExtractor.java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Watermark <span class="title">getCurrentWatermark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// this guarantees that the watermark never goes backwards.</span></span><br><span class="line">	<span class="keyword">long</span> potentialWM = currentMaxTimestamp - maxOutOfOrderness;</span><br><span class="line">	<span class="keyword">if</span> (potentialWM &gt;= lastEmittedWatermark) &#123;</span><br><span class="line">		lastEmittedWatermark = potentialWM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Watermark(lastEmittedWatermark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>debug发现lastEmittedWatermark确实有更新，这说明这个地方是触发了Watermark的值。但是debug的过程中，发现时不时会出现初始值的水位线。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SystemProcessingTimeService.java</span><br><span class="line">TimestampsAndPeriodicWatermarksOperator.java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProcessingTime</span><span class="params">(<span class="keyword">long</span> timestamp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// register next timer</span></span><br><span class="line">	Watermark newWatermark = userFunction.getCurrentWatermark();</span><br><span class="line">	<span class="keyword">if</span> (newWatermark != <span class="keyword">null</span> &amp;&amp; newWatermark.getTimestamp() &gt; currentWatermark) &#123;</span><br><span class="line">		currentWatermark = newWatermark.getTimestamp();</span><br><span class="line">		<span class="comment">// emit watermark</span></span><br><span class="line">		output.emitWatermark(newWatermark);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> now = getProcessingTimeService().getCurrentProcessingTime();</span><br><span class="line">	getProcessingTimeService().registerTimer(now + watermarkInterval, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>TimestampsAndPeriodicWatermarksOperator会做判断：如果新的水位线小于当前的水位线，就不会更新了。<br>终于，顺着StreamInputProcessor–&gt;StatusWatermarkValve理了下来，看见这样的处理逻辑:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">StreamInputProcessor.java</span><br><span class="line">StatusWatermarkValve.java</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findAndOutputNewMinWatermarkAcrossAlignedChannels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> newMinWatermark = Long.MAX_VALUE;</span><br><span class="line">	<span class="comment">// determine new overall watermark by considering only watermark-aligned channels across all channels</span></span><br><span class="line">	<span class="keyword">for</span> (InputChannelStatus channelStatus : channelStatuses) &#123;</span><br><span class="line">		<span class="keyword">if</span> (channelStatus.isWatermarkAligned) &#123;</span><br><span class="line">			newMinWatermark = Math.min(channelStatus.watermark, newMinWatermark);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// we acknowledge and output the new overall watermark if it is larger than the last output watermark</span></span><br><span class="line">	<span class="keyword">if</span> (newMinWatermark &gt; lastOutputWatermark) &#123;</span><br><span class="line">		lastOutputWatermark = newMinWatermark;</span><br><span class="line">		outputHandler.handleWatermark(<span class="keyword">new</span> Watermark(lastOutputWatermark));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里会将所有的channel status的水位线做个汇总：取最小的水位线。那是不是问题出在这里？后面debug了下看看，确实，这个地方有的channel status下的水位线一直是最小的long值那个不正常的水位线，进而导致整体的水位线发送不出去。<br>那么为什么会出现这种情况呢，百思不得其解。<br>当 [window_start_time,window_end_time) 有数据，watermark Time大于等于window_end_time时，会触发window trigger。<br>因为之前运行都是正常的，检查了数据也没问题。去翻改动，有影响的可能就是改了一些算子的并行度。<br>assigntimestampandwatermarks和map的并行度一样了就不能生成水位线了？<br>于是修改了assigntimestampandwatermarks的并行度，window正常fire掉了。amazing。<br>不知道是不是Flink的bug，已经提交。后续更新。</p>
]]></content>
      
        <categories>
            
            <category> Flink </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[那就留下一个故事吧]]></title>
      <url>/2018/02/25/%E9%82%A3%E5%B0%B1%E7%95%99%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%95%85%E4%BA%8B%E5%90%A7/</url>
      <content type="html"><![CDATA[<p>刚好赶上徒游兼职领队招聘的日子，官方说需要一份简历，顺便在此可以总结下自己旅行的日子，谈谈对于旅行的看法。<br><a id="more"></a></p>
<h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><p>北京时间杭州时间龙须山时间2016年4月2日-3日，第一次参加徒游的活动还历历在目，当时我还是个200多斤的大胖子。遇见左边，遇见面瘫，遇见一群有情有义可爱的人儿。<br><img src="/uploads/travel/longxu.jpg" alt="longxu"><br>“大家好，我叫小胖。我现在在运动，已经瘦了10多斤了。”<br>结果我瘦了十几斤的样子如下图。。。<br><img src="/uploads/travel/longxu2.jpg" alt="longxu2"><br>自此喜欢上徒步，将旅行和运动两项自己很喜欢的事情有机地结合起来。<br>因为世事总是难料。<br>所以不敢也不想太过分得执着于将来，把眼前和当下过得饱满就好。<br>也许吧，一切都是虚渺，都是捕风捉影。如果人生一定要有什么意义的话，只有自己才可以定义它的轨迹。那些走过的路，翻过的山川和云海，踏过的沙漠和荒野，游过的岛屿和大海，和路上遇到的人和故事，足够幸运的话还能结交上三五好友，大概就是一步一个脚印走出了人生吧。<br>六月和好友去东极岛玩还偶遇二一hhh。<br><img src="/uploads/travel/dongji.jpg" alt="dongji"></p>
<h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><p>再见徒游已经是2017年的事情了，自此一发不可收拾，就好像身边的驴友说的“很久不走脚会变痒”。<br><img src="/uploads/travel/qingliangfeng.jpg" alt="qingliangfeng"><br><img src="/uploads/travel/dongbai.jpg" alt="dongbai"><br><img src="/uploads/travel/tgl.jpg" alt="tgl"><br><img src="/uploads/travel_2/tgl2.jpg" alt="tgl2"><br><img src="/uploads/travel/btgy.jpg" alt="btgy"><br><img src="/uploads/travel/westlake.jpg" alt="westlake"><br><img src="/uploads/travel/50km.jpg" alt="50km"><br><img src="/uploads/travel/qianba.jpg" alt="qianba"><br>以上都是和徒游走过的路，即使没有光影和文字记录下来，这些经历对我而言都弥足珍贵。<br>“这里时间是完整的，你看着它们从黎明和黄昏庄严展开；每天都像一朵花，像一朵玫瑰，含苞，盛开，没有懊悔而是以接受自然进程的方式凋谢。”<br>花开花谢般从容的日子，大概只有在忘我的旅行中才能找到。只是当时都太快活了，欲辨已忘言。<br>刚开始徒步的时候也许会像那些骑行西藏的哥们一样，“我特码脑抽了，不好好在家带着，在这里受罪”。走着走着，就会感觉每一次完成旅程就好像心灵得到了升华。就像在塔尔寺看到那些信徒一样，每跪拜一下就像风吹一次经幡，祈福一切顺利，心无杂念。</p>
<h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><p>那些不在徒游的日子里，或结伴或兀自独行也走了一些地方。一直觉得旅行中风景和美食好固然得偿所愿，真实的人像和人像下的故事也会给旅行增色不少。<br><img src="/uploads/travel_2/china4.jpg" alt="china4"><br>和好友聊天，得出的结论就是，对于芸芸大众来说，活到最后一定不是比谁赚的钱多，应该是比谁的故事多吧2333。<br><img src="/uploads/travel_2/west3.jpg" alt="west3"><br>在海滩边听着吉他弹唱夹杂着海浪海风的声音，吃着刚捕捞上来的海鲜做的烧烤，喝着当地的啤酒，和朋友聊天，听他们讲这么多年来的故事，从黄昏聊到夕阳，最后满眼繁星。想起之前的一句话，大概意思是说规规矩矩活到一百岁，还不如好酒好肉五十年。<br><img src="/uploads/travel_2/sea.jpg" alt="sea"><br>最近旅行还是会去著名景点打卡，但是会花更多的时间走近当地，和当地人聊天，看到和每天早高峰晚高峰中不一样的微笑和体验。我在高龙撒冷岛的时候，真不想回国过年啊，在那里躺尸一周也足够幸福。<br><img src="/uploads/travel_2/Thiland.jpg" alt="Thiland"><br>尽管吧，我们或许没有太多的共同点，但都有着同样的奇怪，同样对生活的热爱，对未来的迷茫，并且都对这种不确定性的迷茫安之若素。<br><img src="/uploads/travel_2/west1.jpg" alt="west1"><br>大概这样足够美好吧。<br>不知道未来怎么样，但恰是如此才满怀期待。<br><img src="/uploads/travel_2/west4.jpg" alt="west4"></p>
<h2 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h2><p>我在写这篇文章前，和很多朋友在聊对于生活的看法。<br>暂时找不到眼前苟且的意义，但是也算找到了出路。<br><img src="/uploads/travel_2/china1.jpg" alt="china1"><br>辛格有句话，大概的意思是，“看法总会过时，而故事永远常青。”<br><img src="/uploads/travel_2/china3.jpg" alt="china3"><br>最坏最坏的结果就是看法全部错了，<br>但至少能留下一个不错的故事就够了。<br><img src="/uploads/travel_2/china2.jpg" alt="china2"><br>我不入流，这不要紧。每天开心，才是最重要的。<br>“如果你不在乎某一个人对你的看法，一群人对你有什么意见又有什么关系？”<br><img src="/uploads/travel_2/west5.jpg" alt="west5"><br>以前大家聊天都是<br>“在干嘛呢”<br>“吃饭了吗”<br>“今天天气可真好啊”<br>现在都会以“接下去要去哪”作为开端或者结尾。<br>你这么瞎扯淡地游荡到底是想要干嘛呢？<br>这不是一个容易回答的问题。<br>但现在我想能不能换种方式来回答呢？<br>难道一定要知道想要干嘛才行吗。<br><img src="/uploads/travel_2/photo.jpg" alt="photo"></p>
<h2 id="五、"><a href="#五、" class="headerlink" title="五、"></a>五、</h2><p>刚看到朋友圈花花要暂时离开徒游，想着人生啊，总是会有相聚，也会有暂时的离别。只要一起经历的过程足够美好就好，就像骆驼走过的足迹，白牛耕过的地，诗人留下的热泪，时间长河里的一瞬。<br><img src="/uploads/travel_2/qd.jpg" alt="qd"><br>目前的情况下，我还远不足以像Jason和王阿牛那样说走就走踏上环游世界的征程。但是我想啊，weekday还是要好好工作，为之后的旅途积累资本，weekends我希望加入徒游，和我喜欢的领队一样，给这个城市一样有梦想的年轻人带去一个个难忘的周末；和我可爱的旅途中的朋友一块儿，继续在这条挚爱的路上一起行走。<br><img src="/uploads/travel_2/cambodia.jpg" alt="cambodia"><br>我不知道继续流浪到何方，和喜欢的人儿待在一起就很美好。和未知的可能性相逢、厮混、胡搅蛮缠、搏斗，或许落败，或许相爱。最后只留下几个，哪怕只是一个故事，我就没有白走过。<br><img src="/uploads/travel_2/west2.jpg" alt="west2"></p>
]]></content>
      
        
        <tags>
            
            <tag> travel </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Flink四层执行图模型]]></title>
      <url>/2018/01/09/Flink%E5%9B%9B%E5%B1%82%E6%89%A7%E8%A1%8C%E5%9B%BE%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Flink分布式运行时环境]]></title>
      <url>/2018/01/07/Flink%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<h2 id="一、Tasks-and-Operator-Chains（任务与运算链）"><a href="#一、Tasks-and-Operator-Chains（任务与运算链）" class="headerlink" title="一、Tasks and Operator Chains（任务与运算链）"></a>一、Tasks and Operator Chains（任务与运算链）</h2><p>在分布式执行时，Flink会将多个运算子任务链接到分布式计算任务中。每个任务都由一个线程执行。将运算符链接成任务是一个有用的优化：它减少了线程间切换和缓冲的开销，并增加了整体吞吐量，同时减少了延迟。链接行为可以在API中配置。</p>
<p>下图中的示例数据流由五个子任务执行，因此具有五个并行线程。<br><img src="/uploads/Flink分布式运行时环境/tasks_chains.svg" alt="tasks_chains"></p>
<h2 id="二、Job-Managers-Task-Managers-Clients（作业管理器，任务管理器与客户端）"><a href="#二、Job-Managers-Task-Managers-Clients（作业管理器，任务管理器与客户端）" class="headerlink" title="二、Job Managers, Task Managers, Clients（作业管理器，任务管理器与客户端）"></a>二、Job Managers, Task Managers, Clients（作业管理器，任务管理器与客户端）</h2><p>Flink运行时由如下两种进程构成:</p>
<ul>
<li><p><strong>JobManagers</strong>  (也被叫做masters)用来协调分布式系统的的执行。主要功能是调度任务, 调整检查点, 协调失败恢复过程等。<br>一个Flink环境中至少有一个Job Manager，一个高可用的系统在启动时会有多个JobManager，其中一个Job Manager一直是leader，其余的都随时待命，相当于主从机制。</p>
</li>
<li><p><strong>TaskManagers</strong> (也被叫做workers)用来在一条数据流图中执行任务(确切得说这些tasks其实就是subtasks，即计算子任务), 并用于数据流的缓冲和数据交换。<br>一个系统中至少要有一个TaskManager。</p>
</li>
</ul>
<p>JobManagers和TaskManagers可以在如下几种方式下启动:直接在单机上启动, 在容器上启动, 或者通过YARN、Mesos这样的资源框架管理。TaskManagers主动上连到JobManagers, 报告自身是否可用,以便JobManagers分配任务给它们。</p>
<p>client不属于运行时环境的一个组成部分, 但它用于准备并将数据流图发送给JobManager。发送完数据流图后，client可以断开连接，或者保持连接用来接收程序执行结果。client可以用Java或者Scala的形式执行，也可以用命令行(./bin/flink run…)来执行。</p>
<p><img src="/uploads/Flink分布式运行时环境/processes.svg" alt="processes"></p>
<h2 id="三、Task-Slots-and-Resources（任务槽和资源）"><a href="#三、Task-Slots-and-Resources（任务槽和资源）" class="headerlink" title="三、Task Slots and Resources（任务槽和资源）"></a>三、Task Slots and Resources（任务槽和资源）</h2><p>每个worker(TaskManager)都是一个JVM进程，每个子任务都是运行在独立的线程中。为了控制一个worker接收任务的数量，一个任务会分配至少一个任务槽。 </p>
<p>每一个任务槽都代表了一个TaskManager中特定的资源池子集。比如 TaskManager有三个任务槽，每个任务槽都有该TaskManager1/3的管理内存。将资源分槽意味着每一个计算子任务都有指定容量的内存资源，从而不会和其他子任务发生竞争。注意，这里没有对CPU隔离；任务槽只会隔离对应任务的内存。</p>
<p>用户通过调整任务槽的数量，可以自定义每个任务的计算子任务的数量。每个TaskManager只有一个任务槽的话，说明每个任务组都跑在一个独立的JVM上（如果Flink启动在一个独立的容器中）。有多个任务槽说明了有多个计算子任务在共享同一个JVM。在同一个JVM下的任务共享TCP连接(multiplexing：通过多路复用的方式)和心跳信息。任务之间也会共享数据集和数据结构，从而减少每个任务的开销。</p>
<p><img src="/uploads/Flink分布式运行时环境/tasks_slots.svg" alt="tasks_slots"></p>
<p>一般来说，即使计算子任务属于不同的任务，只要它们属于同一个job（作业），Flink都允许子任务共享任务槽。结果就是有可能每个槽都有完整的作业流水的场景。允许任务槽共享有以下两大好处：</p>
<ul>
<li><p>一个Flink集群需要在作业中确保任务槽数量和程序并发量完全一致，而并不需要计算程序中任务（每个任务的并发量也许都不相同）的具体数量。</p>
</li>
<li><p>我们非常容易就可以提高资源利用率。如果没有任务槽共享机制，非密集型的source/map()子任务就会和密集型的window子任务一样阻塞大量资源。如果有这个机制的话，如果在程序的并发量从2提高到6的情况下，就可以让密集型的子任务完全分散到任务管理器中，从而可以显著得提高槽的资源利用率。</p>
</li>
</ul>
<p><img src="/uploads/Flink分布式运行时环境/slot_sharing.svg" alt="slot_sharing"></p>
<p>Flink API中包含一个资源组机制，可以避免不合理的任务槽。</p>
<p><strong>按照以往的经验来看，默认的任务槽数量应设置成CPU核心的数量。如果使用超线程技术，每个槽中甚至可以调度两个硬件线程。</strong></p>
<h2 id="四、State-Backends（后端存储）"><a href="#四、State-Backends（后端存储）" class="headerlink" title="四、State Backends（后端存储）"></a>四、State Backends（后端存储）</h2><p>通过键值对索引的数据结构保存在选定的后端存储中。有的后端存储使用内存中的哈希表来存储数据，另外的后端存储会使用RocksDB来存储键值对。除了定义保存状态的数据结构外，后端存储还实现了获取键值对的特定时间点快照的功能，该功能可以将快照保存为检查点的一部分。</p>
<p><img src="/uploads/Flink分布式运行时环境/checkpoints.svg" alt="checkpoints"></p>
<h2 id="五、Savepoints（保存点）"><a href="#五、Savepoints（保存点）" class="headerlink" title="五、Savepoints（保存点）"></a>五、Savepoints（保存点）</h2><p>使用Data Stream API的程序可以从保存点恢复过来。保存点可以在不丢失状态的情况下更新程序和Flink集群。</p>
<p>保存点是一种手动触发的检查点，获取程序快照并将其写入后端存储中。因此保存点依赖于常规检查点的机制。在程序执行期间，会定期得在worker节点生成快照和检查点。只有最新一个有效的检查点是对Flink修复机制有效的，一旦有新的检查点生成了，那些旧的检查点就可以被安全移除了。</p>
<p>保存点和定期检查点在大部分情况下很像，除了保存点是用户手动触发的，当新的检查点生成时，老的检查点不会自动到期失效。保存点可以通过命令行生成，也可以在调用 REST API 取消作业时产生。</p>
]]></content>
      
        <categories>
            
            <category> Flink </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[把魂丢在了腾格里]]></title>
      <url>/2017/10/11/%E6%8A%8A%E9%AD%82%E4%B8%A2%E5%9C%A8%E4%BA%86%E8%85%BE%E6%A0%BC%E9%87%8C/</url>
      <content type="html"><![CDATA[<p><img src="/uploads/tgl1.jpg" alt="tgl1"></p>
<p><img src="/uploads/tgl2.jpg" alt="tgl2"></p>
<p><img src="/uploads/tgl3.jpg" alt="tgl3"></p>
]]></content>
      
        
        <tags>
            
            <tag> travel </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网格问题]]></title>
      <url>/2017/02/24/%E7%BD%91%E6%A0%BC%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>今天看到一个算法题，题目如下：</p>
<p>猪场有一个x*y的网格盒子，网格的行编号为0~x-1，列编号为0~y-1。每个格子至多可以放一块蛋糕，任意两块蛋糕之间的欧几里得距离不能等于2。对于两个格子坐标（x1,y1),(x2,y2)的欧几里得距离为((x1-x2)^2+(y1-y2)^2)的算术平方根，猪场老板想知道最多可以放多少块蛋糕在网络格子里。</p>
<h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>x&gt;=1,y&lt;=1000</p>
<h3 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h3><p>输出一个最多可以放的蛋糕数和网格的情况。</p>
<h3 id="输入例子："><a href="#输入例子：" class="headerlink" title="输入例子："></a>输入例子：</h3><p>x=3，y=2</p>
<h3 id="输出例子："><a href="#输出例子：" class="headerlink" title="输出例子："></a>输出例子：</h3><p>4</p>
<h3 id="我的思考："><a href="#我的思考：" class="headerlink" title="我的思考："></a>我的思考：</h3><p>若要满足题目条件，同一行的两个蛋糕要隔两行以上，且同一列的蛋糕要隔两列以上。</p>
<p>要满足最大化的条件，则同一行的两个蛋糕隔两行，同一列的蛋糕隔两列。</p>
<p>经过演算，一种是2<em>2方块组每隔两行或者两列铺列开来，另一种是对角线</em>2每隔两个对角线铺列开来。本质其实是一样的，都是满足上述最大化的条件。</p>
<h3 id="我实现了第一种方案："><a href="#我实现了第一种方案：" class="headerlink" title="我实现了第一种方案："></a>我实现了第一种方案：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> new2017;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wangge</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">10</span>, y = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[x][y];</span><br><span class="line">  maxWangge(a);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxWangge</span><span class="params">(<span class="keyword">int</span>[][] a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x=a.length,y=a[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; y; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">2</span> &amp;&amp; j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (a[i - <span class="number">2</span>][j] == <span class="number">0</span> &amp;&amp; a[i][j - <span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">      addCount(a,i,j);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= <span class="number">2</span> &amp;&amp; j &lt; <span class="number">2</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (a[i - <span class="number">2</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">      addCount(a,i,j);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">2</span> &amp;&amp; j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (a[i][j - <span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">      addCount(a,i,j);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     addCount(a,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">"最大的蛋糕数为:"</span>+count);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span>[] b : a)&#123;</span><br><span class="line">   System.out.println(Arrays.toString(b));</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">int</span>[][] a,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">  a[i][j] = <span class="number">1</span>;</span><br><span class="line">  count++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">最大的蛋糕数为:<span class="number">52</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>总结：像今天的网格问题和我之前分享的Wikioi问题，都可以通过二维数组的简单比较实现，记得注意边界值的判断哦。</p>
<p>我是Wikioi推送门：Wikioi的简单实现</p>
<p>作者：有奶喝先森<br>链接：<a href="http://www.jianshu.com/p/ca6c5f3c3950" target="_blank" rel="noopener">http://www.jianshu.com/p/ca6c5f3c3950</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java多线程编程核心技术1——Thread类核心API]]></title>
      <url>/2017/02/17/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF1%E2%80%94%E2%80%94Thread%E7%B1%BB%E6%A0%B8%E5%BF%83API/</url>
      <content type="html"><![CDATA[<h3 id="Thread类相关状态和方法示意图："><a href="#Thread类相关状态和方法示意图：" class="headerlink" title="Thread类相关状态和方法示意图：﻿"></a>Thread类相关状态和方法示意图：﻿</h3><p><img src="/uploads/Thread类相关状态和方法示意图.jpg" alt="Thread类相关状态和方法示意图"></p>
<h1 id="一-Thread类核心API使用"><a href="#一-Thread类核心API使用" class="headerlink" title="﻿一. Thread类核心API使用"></a>﻿一. Thread类核心API使用</h1><a id="more"></a>
<h2 id="1-进程和线程的区别"><a href="#1-进程和线程的区别" class="headerlink" title="1.进程和线程的区别"></a>1.进程和线程的区别</h2><p>进程是一次程序的执行，可以理解成Windows任务管理器的一个exe程序；线程是进程中独立运行的子任务。</p>
<h2 id="2-实现多线程编程有两种方式："><a href="#2-实现多线程编程有两种方式：" class="headerlink" title="2. 实现多线程编程有两种方式："></a>2. 实现多线程编程有两种方式：</h2><p>   2.1 继承Thread类，覆盖run()。（Thread类也实现了Runnaable接口）</p>
<pre><code>优点：如需访问当前线程，无需使用Thread.currentThread()方法。

缺点：已继承Thread类，不能再继承其他父类。
</code></pre><p>   2.2 实现Runnable接口来创建（必须封装到Thread类）。</p>
<pre><code>优点：还可以继承其他父类，适合多个相同线程来处理同一份资源。

缺点：如需访问当前线程，必须使用Thread.currentThread()方法。
</code></pre><p>使用多线程时，代码的运行结果与代码执行顺序或调用顺序无关。</p>
<h2 id="3-currentThread-方法"><a href="#3-currentThread-方法" class="headerlink" title="3.currentThread()方法"></a>3.currentThread()方法</h2><p>Thread.currentThread().getName():返回代码段正在被哪个线程调用的信息。</p>
<h2 id="4-isAlive-判断线程是否处于活动状态。"><a href="#4-isAlive-判断线程是否处于活动状态。" class="headerlink" title="4.isAlive():判断线程是否处于活动状态。"></a>4.isAlive():判断线程是否处于活动状态。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> pgsthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAlive</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestAlive</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"---TestAlive begins---"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Thread.currentThread().getName()="</span>+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Thread.currentThread().isAlive()="</span>+Thread.currentThread().isAlive());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"this.getName()="</span>+<span class="keyword">this</span>.getName());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"this.isAlive()="</span>+<span class="keyword">this</span>.isAlive());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"---TestAlive ends---"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"---run begins---"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Thread.currentThread().getName()="</span>+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Thread.currentThread().isAlive()="</span>+Thread.currentThread().isAlive());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"this.getName()="</span>+<span class="keyword">this</span>.getName());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"this.isAlive()="</span>+<span class="keyword">this</span>.isAlive());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"---run ends---"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pgsthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">TestAlive t = <span class="keyword">new</span> TestAlive();</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Thread(Runnable target):可以传入一个Thread类的对象，将t的run()交给t1执行。</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"main begin t1 isAlive="</span>+t1.isAlive());</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">"A"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"main end t1 isAlive="</span>+t1.isAlive());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">---TestAlive begins---</span><br><span class="line"></span><br><span class="line">Thread.currentThread().getName()=main</span><br><span class="line"></span><br><span class="line">Thread.currentThread().isAlive()=<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.getName()=Thread-<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.isAlive()=<span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">---TestAlive ends---</span><br><span class="line"></span><br><span class="line">main begin t1 isAlive=<span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">main end t1 isAlive=<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">---run begins---</span><br><span class="line"></span><br><span class="line">Thread.currentThread().getName()=A</span><br><span class="line"></span><br><span class="line">Thread.currentThread().isAlive()=<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.getName()=Thread-<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.isAlive()=<span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">---run ends---</span><br></pre></td></tr></table></figure><br>此处的Thread.currentThread()指向t1，this指向t。</p>
<h2 id="5-判读线程是否是停止状态？"><a href="#5-判读线程是否是停止状态？" class="headerlink" title="5.判读线程是否是停止状态？"></a>5.判读线程是否是停止状态？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pgsthread.TestAlive;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterrupt</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> Thread.currentThread().interrupt();</span><br><span class="line"> System.out.println(Thread.interrupted()); <span class="comment">//true</span></span><br><span class="line"> System.out.println(Thread.interrupted()); <span class="comment">//false</span></span><br><span class="line"> TestAlive t = <span class="keyword">new</span> TestAlive();</span><br><span class="line"> t.start();</span><br><span class="line"> t.interrupt();</span><br><span class="line"> System.out.println(t.isInterrupted()); <span class="comment">//true</span></span><br><span class="line"> System.out.println(t.isInterrupted()); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>Thread.currentThread().interrupt();中断的是当前线程，即main。<br><br>this.interrupted():具有将状态位清除为false的功能。<br><br>this.isInterrupted():不清除标志位。<br><br>## 6.主动行为：暂停线程使之阻塞<br><br>suspend():暂停线程；resume()：恢复线程的执行。<br><br>废弃上述两个方法的原因：<br><br>(1) 具有独占性，若在同步代码块中调用suspend()而一直未调用resume()，会锁死该同步代码块。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line"></span><br><span class="line">       print(x);</span><br><span class="line"></span><br><span class="line">       newline();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在进入println(long x)内部是调用suspend()，将锁定该方法，同步锁将不释放。</p>
<p>(2) 不同步，导致线程不安全。</p>
<p>会导致同方法suspend()后的代码得不到执行。</p>
<h2 id="7-线程优先级"><a href="#7-线程优先级" class="headerlink" title="7.线程优先级"></a>7.线程优先级</h2><p>setPriority():优先级分为1~10级，默认为5。</p>
<p>(1)线程的优先级具有继承性。</p>
<p>(2)优先级具有规则性：高优先级的线程总是大部分先执行完，但不代表高优先级的线程全部先执行完。</p>
<p>(3) 优先级具有随机性，并不一定优先级高的线程就一定先执行完。ps，线程优先级与代码中出现的先后顺序无关。</p>
<h2 id="8-守护线程-Thread-setDaemon-true"><a href="#8-守护线程-Thread-setDaemon-true" class="headerlink" title="8.守护线程 Thread.setDaemon(true)"></a>8.守护线程 Thread.setDaemon(true)</h2><p>Java线程分为两种，一种是用户线程，另一种是守护(Daemon)线程。当进程中没有用户线程时，守护线程也将自动销毁。</p>
<h1 id="二-线程间通信"><a href="#二-线程间通信" class="headerlink" title="二. 线程间通信"></a>二. 线程间通信</h1><h2 id="1-等待-通知（wait-notify）机制"><a href="#1-等待-通知（wait-notify）机制" class="headerlink" title="1.等待/通知（wait/notify）机制"></a>1.等待/通知（wait/notify）机制</h2><p>(1) 不使用等待/通知机制</p>
<p>使用sleep()结合while(true)死循环轮询检测，会浪费CPU资源。即两个线程主动式的读取一个共享变量，在花费读取时间的基础上，读到的值不一定是想要的。</p>
<p>(2) 等待/通知机制：</p>
<p>wait()使线程停止运行，notify()使停止的线程继续运行（随机挑选出一个呈wait状态的线程）。</p>
<p>在调用wait()和notify()前必须获得该对象的对象级别锁，即只能在同步方法或者代码块中调用wait()和notify()方法。</p>
<p>※要等到notify()方法的线程将程序执行完，也就是退出synchronized代码块后，当前线程才释放锁，而不是notify()后马上唤醒wait状态的线程进行操作。</p>
<p>(3) sleep():不释放锁；notify():不立即释放锁；wait():释放锁。</p>
<p>(4) 不管线程是wait()还是sleep()状态，调用interrupt()都会抛出InterruptedException异常。只有运行的线程才可被interrupt()。</p>
<p>(5) 唤醒所有等待中的线程：</p>
<p>方法一：多次调用notify()；</p>
<p>方法二：notifyAll()；</p>
<p>(6) 等待wait的条件发生变化：</p>
<p>※用while去判断，while是轮询的，同步的，每一次都会进行判断；而if的话可能有两个线程进去同时进入if语句块就会产生非线程安全问题。</p>
<h2 id="2-生产者-消费者模式实现"><a href="#2-生产者-消费者模式实现" class="headerlink" title="2.生产者/消费者模式实现"></a>2.生产者/消费者模式实现</h2><p>多个生产者与消费者：采用wait/notify机制，但不一定每一次唤醒的都是异类，连续唤醒同类就会产生“假死”，以下加粗的地方则为连续唤醒同类。</p>
<p>生产者1  +1</p>
<p>生产者1 wait</p>
<p>生产者2 wait</p>
<p>消费者1  1-1=0</p>
<p>消费者1 wait</p>
<p>消费者2 wait</p>
<p>生产者1 +1</p>
<p>生产者1 wait</p>
<p>生产者2 wait</p>
<p>解决方案1：改为notifyAll();</p>
<h2 id="3-通过管道进行线程间通信"><a href="#3-通过管道进行线程间通信" class="headerlink" title="3. 通过管道进行线程间通信"></a>3. 通过管道进行线程间通信</h2><p>一个线程发送数据到输出管道，另一个线程从输入管道中读数据。</p>
<p>3.1 字节流：PipedInputStream和PipedOutputStream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PipedInputStream in = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line"></span><br><span class="line">PipedOutputStream out = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line"></span><br><span class="line">out.connect(in);或 in.connect(out);<span class="comment">//使两个管道之间进行通信链接</span></span><br></pre></td></tr></table></figure>
<p>3.2 字符流：PipedReader和PipedWriter，同上connect</p>
<h2 id="4-实例-等待-通知の交叉备份"><a href="#4-实例-等待-通知の交叉备份" class="headerlink" title="4.实例:等待/通知の交叉备份"></a>4.实例:等待/通知の交叉备份</h2><p>使线程具有有序性（设置一个volatile参数）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBTools</span> </span>&#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveA</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   wait();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(<span class="string">"save A!"</span>);</span><br><span class="line"> flag = <span class="keyword">true</span>;</span><br><span class="line"> notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveB</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   wait();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(<span class="string">"save B!"</span>);</span><br><span class="line"> flag = <span class="keyword">false</span>;</span><br><span class="line"> notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> DBTools dbtools;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(DBTools dbtools)</span></span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.dbtools = dbtools;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> dbtools.saveA();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> DBTools dbtools;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">(DBTools dbtools)</span></span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.dbtools = dbtools;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> dbtools.saveB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> DBTools dbtools = <span class="keyword">new</span> DBTools();</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">  ThreadA tA = <span class="keyword">new</span> ThreadA(dbtools);</span><br><span class="line">  tA.start();</span><br><span class="line">  ThreadB tB = <span class="keyword">new</span> ThreadB(dbtools);</span><br><span class="line">  tB.start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>打印结果就是交叉打印的，循环等待和通知所有wait线程，但是只有flag正确的那个线程才能运行，即想要顺序执行的话，只要设置参数就可以。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">save A!</span><br><span class="line">save B!</span><br><span class="line">save A!</span><br><span class="line">save B!</span><br><span class="line">save A!</span><br><span class="line">save B!</span><br></pre></td></tr></table></figure></p>
<h2 id="5-join"><a href="#5-join" class="headerlink" title="5.join()"></a>5.join()</h2><p>比如子线程要进行大量的耗时计算，主线程往往早于子线程结束。当主线程需要等待子线程完成之后再结束，就需要用到join()。</p>
<p>如在t1中调用t2.join();t1暂停，必须等到t2运行完才能继续运行。即等待线程对象销毁。</p>
<p>(1) join与synchronized区别：</p>
<p>join()在内部使用wait()方法进行等待，而synchronized使用的是“对象监视器”原理作为同步。</p>
<p>(2) 如果当前线程对象被中断，则当前线程出现异常（只影响当前线程）。</p>
<p>方法join()与interrupt()方法彼此遇到，会出现异常。但影响的是当前的线程，其他线程正常运行。</p>
<p>(3) join(long)和sleep(long)的区别</p>
<p>join(long):在内部使用的是wait(long)，具有释放锁地特点。在内部执行wait(long)后，当前线程的锁被释放，其他线程就可以调用此线程中的同步方法了。</p>
<p>而sleep(long)不释放锁。</p>
<p>(4) 经过运行如下代码发现join后面的代码有可能提前运行，可能会出现以下结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jointhread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ThreadB b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(ThreadB b)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">super</span>();</span><br><span class="line"> <span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">   System.out.println(<span class="string">"A begins at "</span> + System.currentTimeMillis());</span><br><span class="line">   Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">   System.out.println(<span class="string">"A ends at "</span> + System.currentTimeMillis());</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">  e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jointhread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">"B begins at "</span> + System.currentTimeMillis());</span><br><span class="line">  Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">  System.out.println(<span class="string">"B ends at "</span> + System.currentTimeMillis());</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">  e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jointhread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  ThreadB b = <span class="keyword">new</span> ThreadB();</span><br><span class="line">  ThreadA a = <span class="keyword">new</span> ThreadA(b);</span><br><span class="line">  a.start();</span><br><span class="line">  b.start();</span><br><span class="line">  b.join(<span class="number">2000</span>);</span><br><span class="line">  System.out.println(<span class="string">"main ends at "</span> + System.currentTimeMillis());</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">  e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A begins at <span class="number">1486956475786</span></span><br><span class="line">A ends at <span class="number">1486956480825</span></span><br><span class="line">main ends at <span class="number">1486956480857</span></span><br><span class="line">B begins at <span class="number">1486956480872</span></span><br><span class="line">B ends at <span class="number">1486956485880</span></span><br></pre></td></tr></table></figure><br>step1. b.join(2000)先抢到B锁，然后将B锁释放；</p>
<p>step2. ThreadA抢到B锁，打印 A begins 并且sleep(5000)；</p>
<p>step3. ThreadA打印 A ends，并释放锁；</p>
<p>step4. 此时join(2000)和ThreadB争抢锁，而join(2000)再次抢到锁，发现时间已过，释放锁后打印main ends；</p>
<p>step5. ThreadB抢到锁打印B begins；</p>
<p>step6. 5秒之后再打印B ends。</p>
<p>运行结果2：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A begins at <span class="number">1486956475786</span></span><br><span class="line">A ends at <span class="number">1486956480825</span></span><br><span class="line">B begins at <span class="number">1486956480872</span></span><br><span class="line">B ends at <span class="number">1486956485880</span></span><br><span class="line">main ends at <span class="number">1486956485880</span></span><br></pre></td></tr></table></figure><br>step1. b.join(2000)先抢到B锁，然后将B锁释放；</p>
<p>step2. ThreadA抢到B锁，打印 A begins 并且sleep(5000)；</p>
<p>step3. ThreadA打印 A ends，并释放锁；</p>
<p>step4. 此时join(2000)和ThreadB争抢锁，而ThreadB抢到锁后执行sleep(5000)后释放锁；</p>
<p>step5. main ends 在最后输出。</p>
<p>运行结果3：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A begins at <span class="number">1486956475786</span></span><br><span class="line">A ends at <span class="number">1486956480825</span></span><br><span class="line">B begins at <span class="number">1486956480872</span></span><br><span class="line">main ends at <span class="number">1486956480872</span></span><br><span class="line">B ends at <span class="number">1486956485880</span></span><br></pre></td></tr></table></figure><br>step1. b.join(2000)先抢到B锁，然后将B锁释放；</p>
<p>step2. ThreadA抢到B锁，打印 A begins 并且sleep(5000)；</p>
<p>step3. ThreadA打印 A ends，并释放锁；</p>
<p>step4. 此时join(2000)和ThreadB争抢锁，而join(2000)再次抢到锁，发现时间已过，释放锁后打印main ends；</p>
<p>step5. ThreadB抢到锁打印B begins；</p>
<p>step6. 这时main ends 也异步输出；</p>
<p>step7. 打印B ends。</p>
<h2 id="6-类ThreadLocal"><a href="#6-类ThreadLocal" class="headerlink" title="6.类ThreadLocal"></a>6.类ThreadLocal</h2><p>变量值的共享：public static +变量名；</p>
<p>每一个线程都有自己的共享变量：采用类ThreadLocal，使每一个线程绑定自己的值,保证隔离性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> localthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tools</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocalExt t1 = <span class="keyword">new</span> ThreadLocalExt();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> localthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExt</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> Date().getTime();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> localthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">   System.out.println(<span class="string">"ThreadA = "</span> + Tools.t1.get());</span><br><span class="line">   Thread.sleep(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">  e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> localthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  System.out.println(<span class="string">"main ="</span> + Tools.t1.get());</span><br><span class="line">  Thread.sleep(<span class="number">100</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"> ThreadA a = <span class="keyword">new</span> ThreadA();</span><br><span class="line"> a.start();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果为10个main打印的值相等，10个ThreadA 打印的值也相等，但main和ThreadA 的不相等。</p>
<p>说明ThreadLocal能够实现一个线程享有一个专属变量。</p>
<h2 id="7-类InheritableThreadLocal"><a href="#7-类InheritableThreadLocal" class="headerlink" title="7.类InheritableThreadLocal"></a>7.类InheritableThreadLocal</h2><p>可以在子线程中取得父线程继承下来的值。</p>
<p>(1) 将上例中Tools.java的ThreadLocal改为InheritableThreadLocal，即可得到ThreadA 打印的值和main一样，可谓继承性。</p>
<p>(2) InheritableThreadLocal.childValue(Object object) : 可以修改子线程中的值。</p>
<p>(3) 如果子线程取得值的同时，主线程将InheritableThreadLocal中的值进行修改，子线程拿到的值还是旧值。</p>
<h1 id="三-线程组"><a href="#三-线程组" class="headerlink" title="三. 线程组"></a>三. 线程组</h1><p>1.作用：可以批量管理线程或线程组对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread aRunnable = <span class="keyword">new</span> ThreadA();</span><br><span class="line"></span><br><span class="line">ThreadGroup group = <span class="keyword">new</span> ThreadGroup(<span class="string">"小胖的线程组"</span>)；</span><br><span class="line"></span><br><span class="line">Thread aThread = <span class="keyword">new</span> Thread(group, aRunnable);</span><br></pre></td></tr></table></figure><br>2.在实例化一个线程组如果不指定所属的线程组，则该线程组自动归到当前线程对象所属的线程组中，也就是隐式地在一个线程组中添加了一个子线程组。</p>
<p>JVM的根线程组是system，再取其父线程组则出现异常。</p>
<p>3.递归与非递归取得组内对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enumerate(ThreadGroup, <span class="keyword">true</span>);<span class="comment">//递归（打印A-&gt;B）</span></span><br><span class="line"></span><br><span class="line">enumerate(ThreadGroup, <span class="keyword">false</span>);<span class="comment">//非递归(只打印A)</span></span><br></pre></td></tr></table></figure><br>4.在默认的情况下，线程组中的一个线程出错，不影响其他线程的运行。</p>
<p>博客迁移：年初发表在简书的Java多线程系列，原文链接：<a href="http://www.jianshu.com/p/3e9bb3e24b6e" target="_blank" rel="noopener">Java多线程编程核心技术1——Thread类核心API</a></p>
]]></content>
      
        <categories>
            
            <category> Java多线程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Wikioi]]></title>
      <url>/2017/02/17/Wikioi/</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> new2017;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wikioi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组构建</span></span><br><span class="line"></span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"please input the height:"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[n][];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">a[i] = <span class="keyword">new</span> <span class="keyword">int</span>[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"please input datas:"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line"></span><br><span class="line">a[i][j] = scan.nextInt();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int[][] a = &#123; &#123; 7 &#125;, &#123; 3, 8 &#125;, &#123; 8, 1, 0 &#125;, &#123; 2, 7, 4, 4 &#125;, &#123; 4, 5, 2, 6, 5 &#125; &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int n = a.length;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0x80000000</span>;<span class="comment">// -2147483648</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;<span class="comment">// 第一层</span></span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span>) &#123;<span class="comment">// 每一层的最左边单独处理</span></span><br><span class="line"></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + a[i][j];</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == i) &#123;<span class="comment">// 每一层的最右边单独处理</span></span><br><span class="line"></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][i - <span class="number">1</span>] + a[i][j];</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 中间的比较对应的上面两个哪个大</span></span><br><span class="line"></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &gt; dp[i - <span class="number">1</span>][j] ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] : dp[i - <span class="number">1</span>][j] + a[i][j];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;<span class="comment">// 遍历最后一层</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dp[n - <span class="number">1</span>][j] &gt; ans) &#123;</span><br><span class="line"></span><br><span class="line">ans = dp[n - <span class="number">1</span>][j];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">please input the height:</span><br><span class="line"><span class="number">5</span></span><br><span class="line">please input datas:</span><br><span class="line"></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><br>作者：有奶喝先森<br>链接：<a href="http://www.jianshu.com/p/29707d65f420" target="_blank" rel="noopener">http://www.jianshu.com/p/29707d65f420</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TireTree]]></title>
      <url>/2017/02/17/TireTree/</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tiretree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TireTree</span> </span>&#123;<span class="comment">// Baidu搜索用到的数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node	root;<span class="comment">//根节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TireTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">root = <span class="keyword">new</span> Node(); <span class="comment">// 构造：Tree下面的Node</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Node t = root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;<span class="comment">// i change , and t change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己定义了一套规则，每一次都是26个位置对应到26个字母</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (t.nodes[str.charAt(i) - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;<span class="comment">// 如果不存在该位置</span></span><br><span class="line"></span><br><span class="line">Node node = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">t.nodes[str.charAt(i) - <span class="string">'a'</span>] = node;<span class="comment">// 把新建的node位置赋给这个值-&gt;t.nodes[str.charAt(i) - 'a']</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t = t.nodes[str.charAt(i) - <span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t.isStr = <span class="keyword">true</span>;<span class="comment">// 令插入的最后一个字符为true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node t = new Node();//root是TireTree构造出来的，这个root可以应用在find中去判断</span></span><br><span class="line"></span><br><span class="line">Node t = root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length() &amp;&amp; t != <span class="keyword">null</span>; i++) &#123;<span class="comment">// t != null ----&gt;&gt;对应的这个节点不为空</span></span><br><span class="line"></span><br><span class="line">t = t.nodes[str.charAt(i) - <span class="string">'a'</span>];<span class="comment">// 循环遍历</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (t != <span class="keyword">null</span> &amp;&amp; t.isStr);<span class="comment">// 最后一位不为空且标志位为true，isStr：避免树中有abcde，abc也蒙混过关了</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;<span class="comment">// 代表每一个节点（一个字符）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span>	isStr;	<span class="comment">// 字符串末尾的标志</span></span><br><span class="line"></span><br><span class="line">Node[]	nodes;	<span class="comment">// Node[26]数组</span></span><br><span class="line"></span><br><span class="line">Node() &#123;</span><br><span class="line"></span><br><span class="line">isStr = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">nodes = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">TireTree tireTree = <span class="keyword">new</span> TireTree();</span><br><span class="line"></span><br><span class="line">tireTree.insert(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">tireTree.insert(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">tireTree.insert(<span class="string">"bcd"</span>);</span><br><span class="line"></span><br><span class="line">tireTree.insert(<span class="string">"cdefg"</span>);</span><br><span class="line"></span><br><span class="line">tireTree.insert(<span class="string">"aaaaa"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"abc:"</span> + tireTree.find(<span class="string">"abc"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"abd:"</span> + tireTree.find(<span class="string">"abd"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"abcd:"</span> + tireTree.find(<span class="string">"abcd"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"abcd:"</span> + tireTree.find(<span class="string">"ab"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"bc:"</span> + tireTree.find(<span class="string">"bc"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"bcd:"</span> + tireTree.find(<span class="string">"bcd"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"cdefg:"</span> + tireTree.find(<span class="string">"cdefg"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"aaaaa:"</span> + tireTree.find(<span class="string">"aaaaa"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">abc:<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">abd:<span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">abcd:<span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">abcd:<span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">bc:<span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">bcd:<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">cdefg:<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">aaaaa:<span class="keyword">true</span></span><br></pre></td></tr></table></figure><br>作者：有奶喝先森<br>链接：<a href="http://www.jianshu.com/p/88bb88051730" target="_blank" rel="noopener">http://www.jianshu.com/p/88bb88051730</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java多线程编程核心技术4--单例程式与多线程]]></title>
      <url>/2017/02/17/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF4-%E5%8D%95%E4%BE%8B%E7%A8%8B%E5%BC%8F%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>1.立即加载/饿汉模式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(MyObject.getInstance().hashCode());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> MyObject myObject = <span class="keyword">new</span> MyObject();</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> myObject;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">  MyThread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">  MyThread t3 = <span class="keyword">new</span> MyThread();</span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">  t3.start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果皆为：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11077203</span></span><br></pre></td></tr></table></figure><br>2.延迟加载/懒汉模式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject2</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> MyObject2 myObject;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyObject2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (myObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);<span class="comment">//模拟在创建对象前做一些准备工作</span></span><br><span class="line">    myObject = <span class="keyword">new</span> MyObject2();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> myObject;                   </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在多线程中，就会出现取出多个实例的情况，与单例模式的初衷是相背离的。运行结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11077203</span></span><br><span class="line"></span><br><span class="line"><span class="number">14576877</span></span><br><span class="line"></span><br><span class="line"><span class="number">12677476</span></span><br></pre></td></tr></table></figure><br>3.懒汉模式的改进方法</p>
<p>3.1 整个getInstance()方法声明synchronized关键字 ，但是效率太低。</p>
<p>3.2 在getInstance()方法里声明MyObject.class的synchronized同步语句块，其实相当于全部代码被上锁，效率依旧很低。</p>
<p>3.3 在某些重要的代码实施同步语句块，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject3</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> MyObject3 myObject;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyObject3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (myObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">synchronized</span>(MyObject3.class)&#123;</span><br><span class="line">     myObject = <span class="keyword">new</span> MyObject3();</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> myObject;                   </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>虽然大大提高效率，但是非线程安全，无效。</p>
<p>3.4 使用DCL双检查锁机制 – 推荐<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject4</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> MyObject4 myObject;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyObject4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (MyObject4.class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (myObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">     Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">     myObject = <span class="keyword">new</span> MyObject4();</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> myObject;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.5 静态内部类方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject5</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObjectHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> MyObject5 myObject = <span class="keyword">new</span> MyObject5();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyObject5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> MyObjectHandler.myObject;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.6 序列化与反序列化解决：在反序列化中使用readResolve()方法（略）。</p>
<p>3.7 使用static代码块实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject6</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> MyObject6 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> &#123;</span><br><span class="line">  instance = <span class="keyword">new</span> MyObject6();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyObject6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.8 使用枚举数据类型enum：</p>
<p>使用枚举类时，构造方法会被自动调用。（但不要将枚举类进行曝露，应将枚举类包装在一个正常类中，遵守职责单一原则）</p>
<p>作者：有奶喝先森<br>链接：<a href="http://www.jianshu.com/p/442d0e304e76" target="_blank" rel="noopener">http://www.jianshu.com/p/442d0e304e76</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      
        <categories>
            
            <category> Java多线程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java多线程编程核心技术3——定时器Timer]]></title>
      <url>/2017/02/17/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF3%E2%80%94%E2%80%94%E5%AE%9A%E6%97%B6%E5%99%A8Timer/</url>
      <content type="html"><![CDATA[<p>Timer类的主要作用是设置计划任务，但封装任务的却是TimerTask类。</p>
<p>1.Timer.schedule(TimerTask task,Date time):在指定日期执行某一次任务。</p>
<p>任务执行完进程不会销毁，创建1个Timer就是启动一个新的线程，该线程不是守护线程，会一直运行下去。</p>
<p>方案：Timer timer = new Timer(true);//设置其为守护线程</p>
<p>2.Timer中允许多个TimerTask任务</p>
<p>TimerTask是以队列的方式一个一个执行的，所以预期的执行时间可能和真实的执行时间不一样。可能前面的任务耗时过长，那么后面的任务运行时间也会被延后。</p>
<p>3.Timer.schedule(TimerTask task,Date firstTime,long period):在指定日期之后的间隔周期，无限循环的执行某一个任务。</p>
<p>ps，若计划时间早于当前时间，则立即执行task任务。</p>
<ol>
<li>TimerTask的cancel():将自身从任务队列中清楚，其他任务不受影响。</li>
</ol>
<p>Timer类的cancel(）:将任务队列中的所有任务清空。ps，并一定会马上停止所有任务，原因在于Timer类中的cancel()有时并没有争抢到queue锁，而让TimerTask类中的任务继续执行。</p>
<p>5.Timer.schedule(TimerTask task,long delay):在当前时间的基础上延迟多长时间执行任务。</p>
<p>6.Timer.schedule(TimerTask task,long delay,long period):在当前时间的基础上延迟多长时间执行任务,再以某一时间间隔执行任务。</p>
<p>7.Timer.scheduleAtFixedRate(TimerTask task,Date firstTime,long period)</p>
<p>schedule方法和scheduleAtFixedRate方法都是按顺序执行的，所以不用担心非线程安全的问题。</p>
<p>schedule方法和scheduleAtFixedRate方法的区别在于：</p>
<p>schedule不具有追赶性；</p>
<p>scheduleAtFixedRate具有追赶性，即如果计划时间早于当前时间，这个时间段内的task会被“补充性”的执行下。</p>
<p>Timer可以用于Android技术中，实现类似于轮询、动画等功能。</p>
<p>作者：有奶喝先森<br>链接：<a href="http://www.jianshu.com/p/e3b817ef664a" target="_blank" rel="noopener">http://www.jianshu.com/p/e3b817ef664a</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      
        <categories>
            
            <category> Java多线程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java多线程编程核心技术2——同步]]></title>
      <url>/2017/02/17/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF2%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5/</url>
      <content type="html"><![CDATA[<h1 id="一-对象及变量的并发访问"><a href="#一-对象及变量的并发访问" class="headerlink" title="一. 对象及变量的并发访问"></a>一. 对象及变量的并发访问</h1><p>非线程安全会发生在多个线程并发访问同一个对象的实例变量时，会产生脏读，读取到的数据是被更改过的。而线程安全各个线程获得的实例变量的值都是经过同步处理的，不会出现脏读。</p>
<h2 id="1-线程是否安全呢？"><a href="#1-线程是否安全呢？" class="headerlink" title="1.线程是否安全呢？"></a>1.线程是否安全呢？</h2><p>(1) 如果是方法内部的私有变量，不存在非线程安全问题。</p>
<p>(2) 多线程访问的是同一个对象的实例变量时，有可能出现线程不安全问题。</p>
<p>(3) 多个线程访问的是同步方法的话，一定是线程安全的。</p>
<p>(4) 多个线程对应的是多个对象时，出现的结果就会是异步的，但是线程安全。</p>
<h2 id="2-synchronized关键字"><a href="#2-synchronized关键字" class="headerlink" title="2. synchronized关键字"></a>2. synchronized关键字</h2><a id="more"></a>
<p>(1) synchronized获得的是对象锁，而不是把synchronized下面的方法或者代码块当做锁。</p>
<p>(2) synchronized声明的方法一定是排队执行的（同步的），只有共享资源的读写访问才需要同步化。</p>
<p>(3) 线程A和线程B访问同一个object对象的两个同步的方法，线程A先获取object对象的Lock锁，B线程可以以异步的方式调用object对象中的非同步方法，但是想访问该对象的同步方法的话，必须得等待，不管想访问的是不是和线程A同一个同步方法。</p>
<p>(4) synchronized有锁重入的功能，即自己可以再次获取自己的内部锁，可重入锁也支持父子类继承关系中，即子类可以通过可重入锁访问父类的方法。若不可重入的话，就会造成死锁。</p>
<p>(5) 当一个线程执行的代码出现异常时，其持有的锁会自动释放(即该线程结束执行)。</p>
<p>(6) 同步不具有继承性。</p>
<p>(7) 锁定的对象改变，比如String，可能导致同步锁无效（因为锁变了）。但是只要对象不变，对象的属性被改变，锁还是同一个。</p>
<h2 id="3-synchronized同步语句块"><a href="#3-synchronized同步语句块" class="headerlink" title="3.synchronized同步语句块"></a>3.synchronized同步语句块</h2><p>synchronized同步方法是对当前对象加锁，同步代码块则是对某一个对象加锁。synchronized同步代码块运行效率应该大于同步方法。</p>
<p>synchronized(this)：也是锁定当前对象的。</p>
<p>synchronized(非this对象)：使用同步代码块来锁定非this对象，则synchronized(非this对象)与同步方法是异步的，不与其他锁this同步方法争抢this锁，可以大大提高效率。synchronized同步代码块都不采用String作为锁对象，易造成死锁。</p>
<h2 id="4-synchronized关键字"><a href="#4-synchronized关键字" class="headerlink" title="4.synchronized关键字"></a>4.synchronized关键字</h2><p>加到static静态方法上是给Class类加上锁（Class锁可以对类得所有对象实例起作用），而加到非static静态方法上是给对象上锁。</p>
<p>synchronized关键字加到static静态方法上是给Class类加上锁 = synchronized(xxx.Class){}</p>
<h2 id="5-多线程的死锁"><a href="#5-多线程的死锁" class="headerlink" title="5.多线程的死锁"></a>5.多线程的死锁</h2><p>因为不同的线程都在等待根本不可能被释放的锁，从而导致所有的任务都无法继续执行。</p>
<p>比如线程A持有了锁1在等待锁2，线程A持有了锁2在等待锁1–》导致死锁。</p>
<p>解决方案：不使用嵌套的synchronized代码结构。</p>
<h2 id="6-内置类与静态内置类（补充介绍）"><a href="#6-内置类与静态内置类（补充介绍）" class="headerlink" title="6.内置类与静态内置类（补充介绍）"></a>6.内置类与静态内置类（补充介绍）</h2><p>非静态内置类：指定对象.new 内置类();</p>
<p>静态内置类：可直接new 内置类();</p>
<h2 id="7-volatile关键字："><a href="#7-volatile关键字：" class="headerlink" title="7.volatile关键字："></a>7.volatile关键字：</h2><p>使变量在多个线程中可见</p>
<p>作用：强制从公共堆栈中获取变量的值，而不是从线程私有数据栈中获取。</p>
<p>※ 在JVM被设置为-server模式时是为了线程运行的效率，线程一直在私有堆栈中获取变量的值。</p>
<p>在-server模式下，公共堆栈的值和线程私有数据栈的值不同步，加了volatile后就会强制从公共堆栈中读写。</p>
<p>※volatile和synchronized的比较：</p>
<p>(1) volatile只能修饰变量，是轻量级实现，所以性能比synchronized好。</p>
<p>(2) 多线程访问volatile不会阻塞，而访问synchronized会阻塞。</p>
<p>(3) volatile能保证数据可见性，但不具备同步性，不支持原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为他会将私有内存和共有内存中的数据做同步。</p>
<p>(4) 两者功能属性不同，synchronized解决的是多个线程之间访问资源的同步性；</p>
<p>volatile解决变量在多个线程之间的可见性，即：在多个线程可以感知实例变量被修改了，并且可以获得最新的值引用，也就是用多线程读取共享变量时能获得最新值引用。</p>
<p>volatile int i</p>
<p>i++;</p>
<p>i++有如下三个步骤：</p>
<p>(1) 从内存中获取i的值；</p>
<p>(2)计算i的值；</p>
<p>(3) 将i的值写入内存中。</p>
<p>这样的操作不是一个原子操作（联想：synchronized修饰的方法或者代码段可以看做一个整体，因此具有原子性)，比如线程B要提取i的值时，线程A还未将计算好的i的值放回内存，则线程B取出来的i的值还是线程A计算前的值。–》线程不安全</p>
<h2 id="8-AtomicInteger-AtomicLong等"><a href="#8-AtomicInteger-AtomicLong等" class="headerlink" title="8.AtomicInteger(AtomicLong等)"></a>8.AtomicInteger(AtomicLong等)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(count.incrementAndGet());<span class="comment">//自动加1//decrementAndGet()自动减1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (;;) &#123; <span class="keyword">int</span> current = get(); <span class="keyword">int</span> next = current + <span class="number">1</span>; <span class="keyword">if</span> (compareAndSet(current, next)) <span class="keyword">return</span> next; &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>Compare And Swap（CAS)：首先，CPU 会将内存中将要被更改的数据与期望的值做比较。然后，当这两个值相等时，CPU 才会将内存中的数值替换为新的值。否则便不做操作。最后，CPU 会将旧的数值返回。这一系列的操作是原子的。简单来说，CAS 的含义是“我认为原有的值应该是什么，如果是，则将原有的值更新为新值，否则不做修改，并告诉我原来的值是多少”。</p>
<p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V。这是一种乐观锁的思路，它相信在它修改之前，没有其它线程去修改它；而Synchronized是一种悲观锁，它认为在它修改之前，一定会有其它线程去修改它，悲观锁效率很低。下面来看一下AtomicInteger是如何利用CAS实现原子性操作的。</p>
<p>但是CAS也是有问题存在的：</p>
<p>CAS的ABA问题</p>
<p>1.进程P1在共享变量中读到值为A</p>
<p>2.P1被抢占了，进程P2执行</p>
<p>3.P2把共享变量里的值从A改成了B，再改回到A，此时被P1抢占。</p>
<p>4.P1回来看到共享变量里的值没有被改变，于是继续执行。</p>
<p>虽然P1以为变量值没有改变，继续执行了，但是这个会引发一些潜在的问题。ABA问题最容易发生在lock free 的算法中的，CAS首当其冲，因为CAS判断的是指针的地址。如果这个地址被重用了呢，问题就很大了。（地址被重用是很经常发生的，一个内存分配后释放了，再分配，很有可能还是原来的地址）</p>
<p>还有一种情况是：单独一个AtomicInteger.incrementAndGet()是线程安全的，但是同时两个AtomicInteger.incrementAndGet()就不一定是线程安全的了，即两个方法之间不是原子的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AtomicLong count = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(count.addAndGet(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(count.addAndGet(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>多个线程调用addNum()时，线程A加了100，还没来得及加1，线程B就进来加了100。</p>
<p>解决方案：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AtomicLong count = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(count.addAndGet(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(count.addAndGet(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="9-synchronized代码块也具有volatile同步的功能"><a href="#9-synchronized代码块也具有volatile同步的功能" class="headerlink" title="9.synchronized代码块也具有volatile同步的功能"></a>9.synchronized代码块也具有volatile同步的功能</h2><p>线程A调用runMethod()，线程B调用stopMethod()，持有的是同一把锁。</p>
<p>当线程A调用完runMethod()后，打印不出”停下来了！”的，因为死循环，被A锁死了。</p>
<p>各线程间的数据值没有可见性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Boolean isContinueRun = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(isContinueRun)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"停下来了！"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    isContinueRun = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>解决方案如下，成功打印”停下来了！”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Boolean isContinueRun = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> anyString = <span class="keyword">new</span> String();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(isContinueRun)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(anyString)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"停下来了！"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    isContinueRun = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>关键字synchronized 保证同一时刻，只有一个线程可以执行某一个方法或某一个代码块。包含两种特性：互斥性和可见性。</p>
<p> 不仅可以解决一个线程看到对象处于不一致的状态，还可以保证进入同步方法或代码块的每个线程，都可以看到由同一个锁保护之前所有的修改结果。（外连互斥，内修可见。）</p>
<h1 id="二-锁的使用"><a href="#二-锁的使用" class="headerlink" title="二. 锁的使用"></a>二. 锁的使用</h1><p>Lock也能实现同步的效果，在使用上更加方便。</p>
<h2 id="1-ReentrantLock类-–-Lock-lock-new-ReentrantLock"><a href="#1-ReentrantLock类-–-Lock-lock-new-ReentrantLock" class="headerlink" title="1. ReentrantLock类  – Lock lock = new ReentrantLock();"></a>1. ReentrantLock类  – Lock lock = new ReentrantLock();</h2><p>(1) 使用ReentrantLock.lock()获取锁（加锁），线程就拥有了“对象监视器”；</p>
<p>其他线程只有等待ReentrantLock.unlock()释放锁（解锁），再次争抢获得锁。</p>
<p>效果和synchronized一致，但线程执行顺序是随机的。</p>
<p>(2) 关键字与wait()/notify()/notifyAll()：实现等待/通知模式，但是notifyAll()的话，需要通知所有处于WAITING状态的线程，会出现相当大的效率问题。</p>
<p>ReentrantLock和Condition对象也同样可以实现。在一个Lock对象里可以创建多个Condition（即对象监视器）实例，可以实现多路通知功能；实例对象可以注册在指定的Condition中，从而可以有选择地进行线程通知，在调度线程上更加灵活。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockService</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> <span class="keyword">public</span> Condition condition = lock.newCondition();</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   lock.lock();</span><br><span class="line">   condition.await();<span class="comment">//必须在调用await()之前先调用lock()以获得同步监视器</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   lock.lock();</span><br><span class="line">   condition.signal();<span class="comment">//还有condition.signalAll();</span></span><br><span class="line">  &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">   lock.unlock();</span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>(3) signalAll()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Condition conditionA = lock.newCondition();</span><br><span class="line"><span class="keyword">public</span> Condition conditionB = lock.newCondition();</span><br><span class="line"><span class="comment">//use:</span></span><br><span class="line">conditionA.signal(); <span class="comment">//or conditionB.signal();</span></span><br></pre></td></tr></table></figure><br>唤醒指定种类的线程，如conditionA.signal(); 只有用了conditionA的线程被唤醒。</p>
<p>(4) 公平锁与非公平锁</p>
<p>公平锁：线程获取锁的顺序是按照线程加锁的顺序来分配的（FIFO）；new ReentrantLock(true);//不一定百分百FIFO，但是基本呈有序。</p>
<p>非公平锁(默认)：锁的抢占机制，随机获得锁。new ReentrantLock(false);</p>
<h2 id="2-相关方法介绍"><a href="#2-相关方法介绍" class="headerlink" title="2.相关方法介绍"></a>2.相关方法介绍</h2><p>(1) int getHoldCount():查询当前线程保持此锁定的个数，也就是调用lock()的次数。</p>
<p>(2) int getQueueLength():返回正获取此锁定的线程估计数，如5个线程，一个线程调用了await()，还有4个线程在等待锁的释放。</p>
<p>(3) int getWaitQueueLength(Condition condition):比如有5个线程，每个线程都执行了同一个condition对象的await()，则结果为5。</p>
<p>(4) boolean hasQueuedThread(Thread thread):查询指定的线程是否正在等待此锁定。</p>
<p>(5) boolean hasWaiters(Condition condition):是否有线程正在等待与此锁定有关的condition条件。</p>
<p>(6) boolean isFair():判断是不是公平锁。</p>
<p>(7) boolean isHeldByCurrentThread():查询当前线程是否保持此锁定。</p>
<p>(8) boolean  isLocked():查询此锁定是否由任意线程保持。</p>
<p>(9) void lockInterruptibly():如果当前线程未被中断，则获取锁定，如果已经被中断则出现异常。</p>
<p>(10) boolean tryLock():仅在调用时锁定未被另一个线程保持的情况下，才获取该锁定。</p>
<p>(11) boolean tryLock(long timeout,TimeUnit unit):若在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁定。</p>
<p>(12) Condition.awaitUninterruptibly():在WAITING情况下interrupt()不会抛出异常。</p>
<p>(13) Condition.awaitUntil(time):线程在等待时间到达前，可以被其他线程唤醒。</p>
<h2 id="3-ReentranReadWriteLock类"><a href="#3-ReentranReadWriteLock类" class="headerlink" title="3.ReentranReadWriteLock类"></a>3.ReentranReadWriteLock类</h2><p>共享锁：读操作相关的锁；排他锁：写操作相关的锁。</p>
<p>读写，写读，写写都是互斥的；读读是异步的，非互斥的。</p>
<p>作者：有奶喝先森<br>链接：<a href="http://www.jianshu.com/p/9178ff321e84" target="_blank" rel="noopener">http://www.jianshu.com/p/9178ff321e84</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      
        <categories>
            
            <category> Java多线程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开个人博客的意义]]></title>
      <url>/2017/02/16/%E5%BC%80%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%84%8F%E4%B9%89/</url>
      <content type="html"></content>
      
        
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
